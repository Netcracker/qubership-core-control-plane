package composite

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/google/uuid"
	"github.com/netcracker/qubership-core-control-plane/dao"
	"github.com/netcracker/qubership-core-control-plane/domain"
	"github.com/netcracker/qubership-core-control-plane/event/bus"
	"github.com/netcracker/qubership-core-control-plane/event/events"
	"github.com/netcracker/qubership-core-control-plane/services/cluster/clusterkey"
	"github.com/netcracker/qubership-core-control-plane/services/envoy"
	"github.com/netcracker/qubership-core-control-plane/services/route/registration"
	"github.com/netcracker/qubership-core-control-plane/tlsmode"
	"github.com/netcracker/qubership-core-control-plane/util/msaddr"
)

func (srv *Service) createFallbackRoutesToBaseline() error {
	log.Infof("Creating fallback routes to public, private and internal gateways in baseline %s", srv.coreBaseNamespace)
	changes, err := srv.dao.WithWTx(func(dao dao.Repository) error {
		deploymentVersion, err := srv.entityService.GetActiveDeploymentVersion(dao)
		if err != nil {
			log.Errorf("Failed to load ACTIVE deployment version during initial configuration of composite service: %v", err)
			return err
		}

		request := registration.ProcessedRequest{
			NodeGroups:          make([]domain.NodeGroup, 0, 3),
			Listeners:           make([]domain.Listener, 0, 3),
			RouteConfigurations: make([]domain.RouteConfiguration, 0, 3),
			ClusterNodeGroups:   make(map[string][]string, 3),
			GroupedRoutes:       registration.NewGroupedRoutesMap(),
			Clusters:            make([]domain.Cluster, 0, 3),
			DeploymentVersions:  []string{deploymentVersion.Version},
			ClusterTlsConfig:    make(map[string]string),
		}

		for _, gateway := range []string{domain.PublicGateway, domain.PrivateGateway, domain.InternalGateway} {
			if err := srv.addFallbackRouteToGateway(&request, gateway); err != nil {
				return err
			}
		}

		log.Info("Creating routes %+v", request)
		if err := srv.regService.RegisterRoutes(context.Background(), dao, request); err != nil {
			log.Error("Failed to save processed routes to in-memory storage: %v", err)
			return err
		}

		for _, gateway := range []string{domain.PublicGateway, domain.PrivateGateway, domain.InternalGateway} {
			if err := envoy.UpdateAllResourceVersions(dao, gateway); err != nil {
				log.Errorf("Failed to update envoy resource versions: %v", err)
				return err
			}
		}
		return nil
	})
	if err != nil {
		log.Errorf("Error in initial composite service configuration transaction: \n %v", err)
		return err
	}

	log.Infof("Publishing changes with initial composite service configuration")
	event := events.NewMultipleChangeEvent(changes)
	err = srv.bus.Publish(bus.TopicMultipleChanges, event)
	if err != nil {
		log.Errorf("Can't publish changes to eventBus \n %v", err)
		return err
	}

	log.Infof("Successfully applied initial composite service configuration")
	return nil
}

func (srv *Service) addFallbackRouteToGateway(request *registration.ProcessedRequest, gateway string) error {
	entityBuilder := registration.NewCommonEntityBuilder(gateway)
	request.NodeGroups = append(request.NodeGroups, entityBuilder.CreateNodeGroup())
	request.Listeners = append(request.Listeners, entityBuilder.CreateListener())

	msAddress := srv.getFallbackAddress(gateway)
	clusterName := clusterkey.DefaultClusterKeyGenerator.GenerateKey(gateway, msAddress)
	cluster := domain.NewCluster(clusterName, false)

	request.ClusterNodeGroups[clusterName] = []string{gateway}

	endpoint := domain.Endpoint{
		Address:                  msAddress.GetNamespacedMicroserviceHost(),
		Port:                     msAddress.GetPort(),
		Protocol:                 msAddress.GetProto(),
		DeploymentVersion:        request.DeploymentVersions[0],
		InitialDeploymentVersion: request.DeploymentVersions[0],
	}
	cluster.Endpoints = []*domain.Endpoint{&endpoint}

	request.Clusters = append(request.Clusters, *cluster)

	if tlsmode.GetMode() == tlsmode.Preferred {
		request.ClusterTlsConfig[cluster.Name] = gateway + "-tls"
	}

	domainRoute := &domain.Route{
		Uuid:                     uuid.New().String(),
		Prefix:                   "/",
		ClusterName:              clusterName,
		HostRewrite:              fmt.Sprintf("%s:%v", msAddress.GetNamespacedMicroserviceHost(), msAddress.GetPort()),
		Version:                  1,
		Timeout:                  domain.NullInt{NullInt64: sql.NullInt64{}},
		IdleTimeout:              domain.NullInt{NullInt64: sql.NullInt64{}},
		DeploymentVersion:        request.DeploymentVersions[0],
		InitialDeploymentVersion: request.DeploymentVersions[0],
		Autogenerated:            false,
		Fallback:                 sql.NullBool{Valid: true, Bool: true},
		RequestHeadersToAdd: []domain.Header{{
			Name:  "X-Token-Signature",
			Value: "%DYNAMIC_METADATA(envoy.filters.http.ext_authz:x.token.signature)%",
		}},
	}
	request.GroupedRoutes.PutRoute("", clusterName, request.DeploymentVersions[0], domainRoute)

	virtualHost := &domain.VirtualHost{
		Name:    gateway,
		Routes:  []*domain.Route{domainRoute},
		Domains: []*domain.VirtualHostDomain{{Domain: "*", Version: 1}},
		Version: 1,
	}
	request.RouteConfigurations = append(request.RouteConfigurations, domain.RouteConfiguration{
		Name:         gateway + "-routes",
		NodeGroupId:  gateway,
		Version:      1,
		VirtualHosts: []*domain.VirtualHost{virtualHost},
	})
	return nil
}

func (srv *Service) getFallbackAddress(gateway string) *msaddr.MicroserviceAddress {
	if tlsmode.GetMode() == tlsmode.Disabled {
		return msaddr.NewMicroserviceAddress(gateway+":8080", srv.coreBaseNamespace)
	} else {
		return msaddr.NewMicroserviceAddress("https://"+gateway+":8443", srv.coreBaseNamespace)
	}
}
