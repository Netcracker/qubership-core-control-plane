package business

import (
	"context"
	"github.com/google/uuid"
	"github.com/netcracker/qubership-core-control-plane/dao"
	"github.com/netcracker/qubership-core-control-plane/domain"
	"github.com/netcracker/qubership-core-control-plane/util"
	"github.com/netcracker/qubership-core-control-plane/util/msaddr"
	"github.com/netcracker/qubership-core-lib-go/v3/logging"
)

var logger = logging.GetLogger("business-route-srv")

type RoutesAutoGenerator struct {
	dao            dao.Repository
	versionService VersionService
}

func NewRoutesAutoGenerator(dao dao.Repository, versionService VersionService) *RoutesAutoGenerator {
	return &RoutesAutoGenerator{
		dao:            dao,
		versionService: versionService,
	}
}

func (g *RoutesAutoGenerator) GenerateRoutes(ctx context.Context, clusterKey, namespace, deploymentVersion string, groupedRoutes []*domain.Route) []*domain.Route {
	ver, err := g.versionService.GetOrCreateDeploymentVersion(g.dao, deploymentVersion)
	if err != nil {
		logger.PanicC(ctx, "Failed to get deployment version %v using dao during routes creation: %v", deploymentVersion, err)
	}

	activeRoutes, candidateRoutes := g.findActiveAndCandidateRoutes(ctx, clusterKey, ver)

	delta := getDelta(ctx, activeRoutes, candidateRoutes, groupedRoutes)
	if len(delta) > 0 {
		logger.DebugC(ctx, "Found delta between active and candidate for cluster %s", clusterKey)
		return GenerateProhibitRoutes(delta, &msaddr.Namespace{Namespace: namespace}, ver.Version)
	} else {
		logger.DebugC(ctx, "There is no delta between Active and Candidate route sets for cluster %s", clusterKey)
	}
	return []*domain.Route{}
}

func (g *RoutesAutoGenerator) findActiveAndCandidateRoutes(ctx context.Context, clusterKey string, deploymentVersion *domain.DeploymentVersion) ([]*domain.Route, []*domain.Route) {
	if deploymentVersion.Stage == "CANDIDATE" {
		activeVersion, err := g.versionService.GetActiveDeploymentVersion(g.dao)
		if err != nil {
			logger.PanicC(ctx, "Autogenerated routes creation failed during loading active deployment version: %v", err)
		}

		activeRoutes, err := g.dao.FindRoutesByClusterNameAndDeploymentVersion(clusterKey, activeVersion.Version)
		if err != nil {
			logger.PanicC(ctx, "Autogenerated routes creation failed during loading active version routes: %v", err)
		}
		candidateRoutes, err := g.dao.FindRoutesByClusterNameAndDeploymentVersion(clusterKey, deploymentVersion.Version)
		if err != nil {
			logger.PanicC(ctx, "Autogenerated routes creation failed during loading candidate version routes: %v", err)
		}
		return activeRoutes, candidateRoutes
	}
	return []*domain.Route{}, []*domain.Route{}
}

func getDelta(ctx context.Context, activeRoutes, candidateRoutes, requestRoutes []*domain.Route) []*domain.Route {
	candidateKeys := make([]string, 0, len(candidateRoutes)+len(requestRoutes))
	for _, candidateRoute := range candidateRoutes {
		if candidateRoute.Regexp == "" {
			candidateKeys = append(candidateKeys, candidateRoute.Prefix)
		} else {
			candidateKeys = append(candidateKeys, candidateRoute.Regexp)
		}
	}
	for _, reqRoute := range requestRoutes {
		if reqRoute.Regexp == "" {
			candidateKeys = append(candidateKeys, reqRoute.Prefix)
		} else {
			candidateKeys = append(candidateKeys, reqRoute.Regexp)
		}
	}
	logger.DebugC(ctx, "Candidate routes: %s", candidateRoutes)

	delta := make([]*domain.Route, 0)
	for _, activeRoute := range activeRoutes {
		if activeRoute.Prefix != "" && !util.SliceContainsElement(candidateKeys, activeRoute.Prefix) ||
			activeRoute.Regexp != "" && !util.SliceContainsElement(candidateKeys, activeRoute.Regexp) {
			logger.DebugC(ctx, "Add route to delta. Cluster: %s, Route: %s", activeRoute.ClusterName, activeRoute.RouteKey)
			delta = append(delta, activeRoute)
		}
	}
	return delta
}

func GenerateProhibitRoutes(routes []*domain.Route, namespace *msaddr.Namespace, deploymentVersion string) []*domain.Route {
	notFoundRoutes := make([]*domain.Route, len(routes))
	for idx, route := range routes {
		newRoute := GenerateProhibitRoute(route, namespace, deploymentVersion)
		notFoundRoutes[idx] = newRoute
	}
	return notFoundRoutes
}

func GenerateProhibitRoute(route *domain.Route, namespace *msaddr.Namespace, deploymentVersion string) *domain.Route {
	// TODO: ROUTE MUST CONTAIN RELATIONS???
	newRoute := route.Clone()

	newRoute.Id = 0
	newRoute.ClusterName = ""
	newRoute.HostRewrite = ""
	newRoute.HostAutoRewrite = domain.NewNullBool(false)
	newRoute.PrefixRewrite = ""
	newRoute.RegexpRewrite = ""
	newRoute.PathRewrite = ""

	newRoute.DirectResponseCode = 404
	newRoute.Autogenerated = true
	newRoute.DeploymentVersion = deploymentVersion
	newRoute.InitialDeploymentVersion = deploymentVersion
	if !namespace.IsCurrentNamespace() {
		namespaceHeaderMatcher := &domain.HeaderMatcher{
			Name:       "namespace",
			Version:    1,
			ExactMatch: namespace.Namespace,
			Route:      newRoute,
		}
		route.HeaderMatchers = append(route.HeaderMatchers, namespaceHeaderMatcher)
	}
	//newRoute.RouteKey = routekey.GenerateKey(*newRoute)
	// TODO move it to generic way of creating route
	newRoute.Uuid = uuid.New().String()
	return newRoute
}
