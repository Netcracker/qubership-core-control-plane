package entity

import (
	"github.com/google/uuid"
	"github.com/netcracker/qubership-core-control-plane/dao"
	"github.com/netcracker/qubership-core-control-plane/domain"
	"github.com/netcracker/qubership-core-control-plane/services/route/routekey"
	"github.com/netcracker/qubership-core-control-plane/util"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestService_PutRouteIfExists(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := prepareRoute(t, inMemDao)
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedRoute.VirtualHostId, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoute, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoute)
	assert.Equal(t, 1, len(actualRoute))
	assert.Contains(t, actualRoute, expectedRoute)
}

func TestService_PutRouteIfExistsWithNoHeaderMatcher(t *testing.T) {
	entityService, inMemDao := getService(t)
	route := &domain.Route{Uuid: uuid.New().String(), VirtualHostId: 1, ClusterName: "test-cluster", DeploymentVersion: "v1", InitialDeploymentVersion: "v1", Autogenerated: true}
	route.RouteKey = routekey.GenerateKey(*route)
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, route.VirtualHostId, route)
	})
	assert.Nil(t, err)

	expectedRoute := route.Clone()
	headerMatcher1 := &domain.HeaderMatcher{Name: "namespace1", ExactMatch: "some1"}
	headerMatcher2 := &domain.HeaderMatcher{Name: "namespace2", ExactMatch: "some2"}
	headerMatcher3 := &domain.HeaderMatcher{Name: "namespace3", ExactMatch: "some3"}
	expectedRoute.HeaderMatchers = []*domain.HeaderMatcher{headerMatcher1, headerMatcher2, headerMatcher3}
	_, err = inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedRoute.VirtualHostId, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoutes)
	assert.Equal(t, 2, len(actualRoutes))
	assert.Contains(t, actualRoutes, expectedRoute)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.NotEmpty(t, actualHeaderMatchers)
	assert.Equal(t, 3, len(actualHeaderMatchers))
	assert.Contains(t, actualHeaderMatchers, headerMatcher1, headerMatcher2, headerMatcher3)

}

func TestService_PutRouteIfDoesNotExist(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := &domain.Route{Uuid: uuid.New().String(), RouteKey: "1", VirtualHostId: 1, ClusterName: "test-cluster",
		DeploymentVersion: "v1", InitialDeploymentVersion: "v1", Autogenerated: true}
	headerMatcher := &domain.HeaderMatcher{Name: "namespace", ExactMatch: "some"}
	hashPolicy := &domain.HashPolicy{HeaderName: "namespace"}
	expectedRoute.HeaderMatchers = []*domain.HeaderMatcher{headerMatcher}
	expectedRoute.HashPolicies = []*domain.HashPolicy{hashPolicy}
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedRoute.VirtualHostId, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoutes)
	assert.Equal(t, 1, len(actualRoutes))
	assert.Contains(t, actualRoutes, expectedRoute)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.NotEmpty(t, actualHeaderMatchers)
	assert.Equal(t, 1, len(actualHeaderMatchers))
	assert.Contains(t, actualHeaderMatchers, headerMatcher)

	actualHashPolicy, err := inMemDao.FindHashPolicyByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Equal(t, 1, len(actualHashPolicy))
	assert.Equal(t, hashPolicy, actualHashPolicy[0])
}

func TestService_PutRouteIfExistsWithNewEmptyHeaderMatcher(t *testing.T) {
	entityService, inMemDao := getService(t)
	route := prepareRoute(t, inMemDao)
	expectedRoute := route.Clone()
	expectedRoute.HeaderMatchers = []*domain.HeaderMatcher{}
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedRoute.VirtualHostId, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoutes)
	assert.Equal(t, 2, len(actualRoutes))
	assert.Contains(t, actualRoutes, expectedRoute)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Empty(t, actualHeaderMatchers)

	actualHashPolicies, err := inMemDao.FindHashPolicyByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Equal(t, 1, len(actualHashPolicies))
}

func TestService_PutRouteIfExistsWithNewHeaderMatcher(t *testing.T) {
	entityService, inMemDao := getService(t)
	route := prepareRoute(t, inMemDao)
	expectedRoute := route.Clone()
	headerMatcher1 := &domain.HeaderMatcher{Name: "namespace1", ExactMatch: "some1"}
	headerMatcher2 := &domain.HeaderMatcher{Name: "namespace2", ExactMatch: "some2"}
	headerMatcher3 := &domain.HeaderMatcher{Name: "namespace3", ExactMatch: "some3"}
	expectedRoute.HeaderMatchers = []*domain.HeaderMatcher{headerMatcher1, headerMatcher2, headerMatcher3}
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedRoute.VirtualHostId, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoutes)
	assert.Equal(t, 2, len(actualRoutes))
	assert.Contains(t, actualRoutes, expectedRoute)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.NotEmpty(t, actualHeaderMatchers)
	assert.Equal(t, 3, len(actualHeaderMatchers))
	assert.Contains(t, actualHeaderMatchers, headerMatcher1, headerMatcher2, headerMatcher3)

	actualHashPolicies, err := inMemDao.FindHashPolicyByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Equal(t, 1, len(actualHashPolicies))
}

func TestService_PutRoutesWhichDoNotExist(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedFirstRoute := &domain.Route{Uuid: uuid.New().String(), Prefix: "/api/v1", VirtualHostId: 1, ClusterName: "test-cluster",
		DeploymentVersion: "v1", InitialDeploymentVersion: "v1"}
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedFirstRoute.VirtualHostId, expectedFirstRoute)
	})
	assert.Nil(t, err)

	expectedSecondRoute := &domain.Route{Uuid: uuid.New().String(), Prefix: "/api/v2", VirtualHostId: 1, ClusterName: "new-cluster",
		DeploymentVersion: "v1", InitialDeploymentVersion: "v1"}
	_, err = inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoute(dao, expectedSecondRoute.VirtualHostId, expectedSecondRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoutes)
	assert.Equal(t, 2, len(actualRoutes))
	assert.Contains(t, actualRoutes, expectedFirstRoute)
	assert.Contains(t, actualRoutes, expectedSecondRoute)
}

func TestService_PutRoutes(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute1 := &domain.Route{Uuid: uuid.New().String(), Prefix: "/", VirtualHostId: 1, ClusterName: "test-cluster",
		DeploymentVersion: "v1", InitialDeploymentVersion: "v1"}
	expectedRoute2 := &domain.Route{Uuid: uuid.New().String(), Prefix: "/a", VirtualHostId: 1, ClusterName: "new-cluster",
		DeploymentVersion: "v1", InitialDeploymentVersion: "v1"}

	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.PutRoutes(dao, []*domain.Route{expectedRoute1, expectedRoute2})
	})
	assert.Nil(t, err)

	actualRoute, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoute)
	assert.Equal(t, 2, len(actualRoute))
	assert.Contains(t, actualRoute, expectedRoute1)
	assert.Contains(t, actualRoute, expectedRoute2)
}

func TestService_DeleteRoutesByAutoGeneratedAndDeploymentVersion(t *testing.T) {
	entityService, inMemDao := getService(t)
	v2 := &domain.DeploymentVersion{Version: "v2", Stage: domain.CandidateStage}
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return dao.SaveDeploymentVersion(v2)
	})
	assert.Nil(t, err)
	expectedFirstRoute := &domain.Route{Uuid: uuid.New().String(), RouteKey: "1", VirtualHostId: 1, ClusterName: "test-cluster", DeploymentVersion: "v1", InitialDeploymentVersion: "v1", Autogenerated: true}
	expectedSecondRoute := &domain.Route{Uuid: uuid.New().String(), RouteKey: "2", VirtualHostId: 1, ClusterName: "new-cluster", DeploymentVersion: "v2", InitialDeploymentVersion: "v2", Autogenerated: true}

	_, err = inMemDao.WithWTx(func(dao dao.Repository) error {
		assert.Nil(t, entityService.PutRoute(dao, expectedFirstRoute.VirtualHostId, expectedFirstRoute))
		return entityService.PutRoute(dao, expectedSecondRoute.VirtualHostId, expectedSecondRoute)
	})
	assert.Nil(t, err)

	_, err = inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRoutesByAutoGeneratedAndDeploymentVersion(dao, true, "v1")
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.NotEmpty(t, actualRoutes)
	assert.Equal(t, 1, len(actualRoutes))
	assert.Contains(t, actualRoutes, expectedSecondRoute)
	assert.NotContains(t, actualRoutes, expectedFirstRoute)
}

func TestService_DeleteRouteByAutoGeneratedAndDeploymentVersion(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := prepareRoute(t, inMemDao)

	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRoutesByAutoGeneratedAndDeploymentVersion(dao, true, "v1")
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.Empty(t, actualRoutes)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Empty(t, actualHeaderMatchers)

	actualHashPolicy, err := inMemDao.FindHashPolicyByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Empty(t, actualHashPolicy)
}

func TestService_DeleteRoutesByAutoGeneratedAndDeploymentVersionWhenNotFound(t *testing.T) {
	entityService, inMemDao := getService(t)
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRoutesByAutoGeneratedAndDeploymentVersion(dao, true, "v2")
	})
	assert.Nil(t, err)
}

func TestService_DeleteRouteByUUID(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := prepareRoute(t, inMemDao)

	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRouteByUUID(dao, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.Empty(t, actualRoutes)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Empty(t, actualHeaderMatchers)

	actualHashPolicy, err := inMemDao.FindHashPolicyByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Empty(t, actualHashPolicy)
}

func TestService_DeleteRouteByUUIDIfDoesNotExist(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := &domain.Route{Uuid: uuid.New().String(), RouteKey: "1", VirtualHostId: 1, ClusterName: "test-cluster", DeploymentVersion: "v1", InitialDeploymentVersion: "v1", Autogenerated: true}

	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRouteByUUID(dao, expectedRoute)
	})
	assert.Nil(t, err)
}

func TestService_DeleteRoutesByUUID(t *testing.T) {
	entityService, inMemDao := getService(t)
	v2 := &domain.DeploymentVersion{Version: "v2", Stage: domain.CandidateStage}
	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return dao.SaveDeploymentVersion(v2)
	})
	assert.Nil(t, err)
	expectedFirstRoute := &domain.Route{Uuid: uuid.New().String(), RouteKey: "1", VirtualHostId: 1, ClusterName: "test-cluster", DeploymentVersion: "v1", InitialDeploymentVersion: "v1", Autogenerated: true}
	expectedSecondRoute := &domain.Route{Uuid: uuid.New().String(), RouteKey: "2", VirtualHostId: 1, ClusterName: "new-cluster", DeploymentVersion: "v2", InitialDeploymentVersion: "v2", Autogenerated: true}

	_, err = inMemDao.WithWTx(func(dao dao.Repository) error {
		assert.Nil(t, entityService.PutRoute(dao, expectedFirstRoute.VirtualHostId, expectedFirstRoute))
		return entityService.PutRoute(dao, expectedSecondRoute.VirtualHostId, expectedSecondRoute)
	})
	assert.Nil(t, err)

	_, err = inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRoutesByUUID(dao, []*domain.Route{expectedFirstRoute, expectedSecondRoute})
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.Empty(t, actualRoutes)
}

func TestService_DeleteRouteCascade(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := prepareRoute(t, inMemDao)

	_, err := inMemDao.WithWTx(func(dao dao.Repository) error {
		return entityService.DeleteRouteCascade(dao, expectedRoute)
	})
	assert.Nil(t, err)

	actualRoutes, err := inMemDao.FindAllRoutes()
	assert.Nil(t, err)
	assert.Empty(t, actualRoutes)

	actualHeaderMatchers, err := inMemDao.FindHeaderMatcherByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Empty(t, actualHeaderMatchers)

	actualHashPolicy, err := inMemDao.FindHashPolicyByRouteId(expectedRoute.Id)
	assert.Nil(t, err)
	assert.Equal(t, 0, len(actualHashPolicy))
}

func TestService_LoadRouteRelations(t *testing.T) {
	entityService, inMemDao := getService(t)
	expectedRoute := prepareRoute(t, inMemDao)

	actualRouteRaw, _, err := inMemDao.WithWTxVal(func(dao dao.Repository) (interface{}, error) {
		actualRoute, err := inMemDao.FindRouteByUuid(expectedRoute.Uuid)
		assert.Nil(t, err)
		assert.NotNil(t, actualRoute)
		return entityService.LoadRouteRelations(dao, actualRoute)
	})
	assert.Nil(t, err)
	assert.NotNil(t, actualRouteRaw)
	actualRoute := actualRouteRaw.(*domain.Route)
	AssertDeepEqual(t, expectedRoute, actualRoute, domain.RouteTable)
}

func prepareRoute(t *testing.T, memDao *dao.InMemDao) *domain.Route {
	route := domain.Route{Uuid: uuid.New().String(), RouteKey: "1", VirtualHostId: 1, ClusterName: "test-cluster",
		DeploymentVersion: "v1", InitialDeploymentVersion: "v1", Autogenerated: true}
	headerMatcher := domain.HeaderMatcher{Name: "namespace", ExactMatch: "some"}
	hashPolicy := domain.HashPolicy{HeaderName: "namespace"}
	route.Id, route.RouteKey, headerMatcher.Id, hashPolicy.Id = saveRoute(t, memDao, route, headerMatcher, hashPolicy)
	headerMatcher.RouteId = route.Id
	hashPolicy.RouteId = route.Id
	route.HeaderMatchers = []*domain.HeaderMatcher{&headerMatcher}
	route.HashPolicies = []*domain.HashPolicy{&hashPolicy}
	route.Version++
	return &route
}

func saveRoute(t *testing.T, memDao *dao.InMemDao, route domain.Route, matcher domain.HeaderMatcher, policy domain.HashPolicy) (int32, string, int32, int32) {
	_, err := memDao.WithWTx(func(dao dao.Repository) error {
		routeForKey := route
		routeForKey.HeaderMatchers = []*domain.HeaderMatcher{&matcher}
		route.RouteKey = routekey.GenerateKey(routeForKey)
		assert.Nil(t, dao.SaveRoute(&route))
		matcher.RouteId = route.Id
		assert.Nil(t, dao.SaveHeaderMatcher(&matcher))
		policy.RouteId = route.Id
		assert.Nil(t, dao.SaveHashPolicy(&policy))
		return nil
	})
	assert.Nil(t, err)
	return route.Id, route.RouteKey, matcher.Id, policy.Id
}

func RoutesEqual(expected, actual *domain.Route) bool {
	if expected == nil || actual == nil {
		return expected == actual
	}
	if expected.Id != actual.Id ||
		expected.RouteKey != actual.RouteKey ||
		expected.ClusterName != actual.ClusterName ||
		expected.VirtualHostId != actual.VirtualHostId ||
		expected.DeploymentVersion != actual.DeploymentVersion ||
		expected.InitialDeploymentVersion != actual.InitialDeploymentVersion ||
		expected.Version != actual.Version ||
		expected.Autogenerated != actual.Autogenerated ||
		expected.Prefix != actual.Prefix ||
		expected.PrefixRewrite != actual.PrefixRewrite ||
		expected.Regexp != actual.Regexp ||
		expected.Path != actual.Path ||
		expected.PathRewrite != actual.PathRewrite ||
		expected.RegexpRewrite != actual.RegexpRewrite ||
		expected.HostAutoRewrite != actual.HostAutoRewrite ||
		expected.HostRewrite != actual.HostRewrite ||
		expected.Timeout != actual.Timeout ||
		expected.IdleTimeout != actual.IdleTimeout ||
		expected.Uuid != actual.Uuid ||
		expected.DirectResponseCode != actual.DirectResponseCode {
		return false
	}

	// compare hash policy
	if len(expected.HashPolicies) != len(actual.HashPolicies) {
		return false
	}
	for _, expectedPolicy := range expected.HashPolicies {
		presentsInBothLists := false
		for _, actualPolicy := range actual.HashPolicies {
			if expectedPolicy.Equals(actualPolicy) {
				presentsInBothLists = true
				break
			}
		}
		if !presentsInBothLists {
			return false
		}
	}
	for _, actualPolicy := range actual.HashPolicies {
		presentsInBothLists := false
		for _, expectedPolicy := range expected.HashPolicies {
			if expectedPolicy.Equals(actualPolicy) {
				presentsInBothLists = true
				break
			}
		}
		if !presentsInBothLists {
			return false
		}
	}

	// compare header matchers
	if len(expected.HeaderMatchers) != len(actual.HeaderMatchers) {
		return false
	}
	for _, expectedMatcher := range expected.HeaderMatchers {
		presentsInBothLists := false
		for _, actualMatcher := range actual.HeaderMatchers {
			if expectedMatcher.Equals(actualMatcher) {
				presentsInBothLists = true
				break
			}
		}
		if !presentsInBothLists {
			return false
		}
	}
	for _, actualMatcher := range actual.HeaderMatchers {
		presentsInBothLists := false
		for _, expectedMatcher := range expected.HeaderMatchers {
			if expectedMatcher.Equals(actualMatcher) {
				presentsInBothLists = true
				break
			}
		}
		if !presentsInBothLists {
			return false
		}
	}

	// compare RequestHeadersToAdd
	if len(expected.RequestHeadersToAdd) != len(actual.RequestHeadersToAdd) {
		return false
	}
	for _, expectedHeader := range expected.RequestHeadersToAdd {
		presentsInBothLists := false
		for _, actualHeader := range actual.RequestHeadersToAdd {
			if expectedHeader.Equals(actualHeader) {
				presentsInBothLists = true
				break
			}
		}
		if !presentsInBothLists {
			return false
		}
	}
	for _, actualHeader := range actual.RequestHeadersToAdd {
		presentsInBothLists := false
		for _, expectedHeader := range expected.RequestHeadersToAdd {
			if expectedHeader.Equals(actualHeader) {
				presentsInBothLists = true
				break
			}
		}
		if !presentsInBothLists {
			return false
		}
	}

	// compare RequestHeadersToRemove
	if len(expected.RequestHeadersToRemove) != len(actual.RequestHeadersToRemove) {
		return false
	}
	for _, expectedHeader := range expected.RequestHeadersToRemove {
		if !util.SliceContainsElement(actual.RequestHeadersToRemove, expectedHeader) {
			return false
		}
	}
	for _, actualHeader := range actual.RequestHeadersToRemove {
		if !util.SliceContainsElement(actual.RequestHeadersToRemove, actualHeader) {
			return false
		}
	}
	return true
}
