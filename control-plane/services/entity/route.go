package entity

import (
	"github.com/go-errors/errors"
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/dao"
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/domain"
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/services/cluster/clusterkey"
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/services/route/routekey"
)

func (srv *Service) LoadRouteRelations(dao dao.Repository, route *domain.Route) (*domain.Route, error) {
	var err error
	route.HeaderMatchers, err = dao.FindHeaderMatcherByRouteId(route.Id)
	if err != nil {
		logger.Errorf("Failed to find header matchers by route id %d : %v", route.Id, err)
		return nil, err
	}
	route.HashPolicies, err = dao.FindHashPolicyByRouteId(route.Id)
	if err != nil {
		logger.Errorf("Failed to find hash policies by route host id %d : %v", route.Id, err)
		return nil, err
	}
	route.DeploymentVersionVal, err = dao.FindDeploymentVersion(route.DeploymentVersion)
	if err != nil {
		logger.Errorf("Failed to find deployment version by version %s : %v", route.DeploymentVersion, err)
		return nil, err
	}
	route.StatefulSession, err = dao.FindStatefulSessionConfigById(route.StatefulSessionId)
	if err != nil {
		logger.Errorf("Failed to find stateful session cookie by route %d : %v", route.Id, err)
		return nil, err
	}
	route.RateLimit, err = dao.FindRateLimitByNameWithHighestPriority(route.RateLimitId)
	if err != nil {
		logger.Errorf("Failed to find rate limit by route %d : %v", route.Id, err)
		return nil, err
	}
	return route, nil
}

func (srv *Service) PutRoutes(dao dao.Repository, routes []*domain.Route) error {
	for _, route := range routes {
		if err := srv.PutRoute(dao, route.VirtualHostId, route); err != nil {
			return err
		}
	}
	return nil
}

func (srv *Service) PutRoute(dao dao.Repository, virtualHostId int32, updateRequest *domain.Route) error {
	updateRequest.VirtualHostId = virtualHostId

	updateRequest.RouteKey = routekey.GenerateKey(*updateRequest)
	srv.routeKeyLock.Lock(updateRequest.RouteKey)
	defer srv.routeKeyLock.Unlock(updateRequest.RouteKey)

	routes, err := dao.FindRoutesByVirtualHostIdAndRouteKey(virtualHostId, updateRequest.RouteKey)
	if err != nil {
		logger.Errorf("Failed to find routes by virtualHostId %v and routeKey %v using DAO: %v", virtualHostId, updateRequest.RouteKey, err)
		return err
	}

	if len(routes) > 0 {
		return srv.mergeAndStoreRoute(dao, routes[0], updateRequest)
	} else {
		dVersion, err := dao.FindDeploymentVersion(updateRequest.DeploymentVersion)
		if err != nil {
			return err
		}
		if dVersion == nil {
			return errors.Errorf("expected DeploymentVersion '%s' not found for route with id '%d'", updateRequest.DeploymentVersion, updateRequest.Id)
		}
		if dVersion.Stage == domain.LegacyStage || dVersion.Stage == domain.ArchivedStage {
			return LegacyRouteDisallowed
		}
		return srv.storeNewRoute(dao, updateRequest)
	}
}

func (srv *Service) DeleteRoutesByAutoGeneratedAndDeploymentVersion(dao dao.Repository, autoGenerated bool, dVersion string) error {
	routesToDelete, err := dao.FindRoutesByAutoGeneratedAndDeploymentVersion(autoGenerated, dVersion)
	if err != nil {
		logger.Errorf("Can't find routes by AutoGenerated %t and deployment version %s: %v", autoGenerated, dVersion, err)
		return err
	}
	for _, routeToDelete := range routesToDelete {
		err = srv.deleteRouteByUUIDInternal(dao, routeToDelete)
		if err != nil {
			logger.Errorf("Can't delete route by uuid %v: %v", routeToDelete, err)
			return err
		}
	}
	return nil
}

func (srv *Service) DeleteRoutesByUUID(dao dao.Repository, routesToDelete []*domain.Route) error {
	for _, routeToDelete := range routesToDelete {
		err := srv.deleteRouteByUUIDInternal(dao, routeToDelete)
		if err != nil {
			logger.Errorf("Can't delete route by uuid %v: %v", routeToDelete, err)
			return err
		}
		logger.Infof("Route %v is deleted", routeToDelete)
	}
	return nil
}

func (srv *Service) DeleteRouteByUUID(dao dao.Repository, routeToDelete *domain.Route) error {
	return srv.deleteRouteByUUIDInternal(dao, routeToDelete)
}

func (srv *Service) deleteRouteByUUIDInternal(dao dao.Repository, routeToDelete *domain.Route) error {
	numberOfDeletedHashPolicies, err := dao.DeleteHashPolicyByRouteId(routeToDelete.Id)
	if err != nil {
		logger.Errorf("Can't delete hash policies by route id %d: %v", routeToDelete.Id, err)
		return err
	}
	logger.Infof("Number of hash policies deleted by route id %d is %d ", routeToDelete.Id, numberOfDeletedHashPolicies)

	err = dao.DeleteRetryPolicyByRouteId(routeToDelete.Id)
	if err != nil {
		logger.Errorf("Can't delete retry policies by route id %d: %v", routeToDelete.Id, err)
		return err
	}

	numberOfDeletedHeaderMatchers, err := dao.DeleteHeaderMatchersByRouteId(routeToDelete.Id)
	if err != nil {
		logger.Errorf("Can't delete header matchers by route id %d: %v", routeToDelete.Id, err)
		return err
	}
	logger.Infof("Number of header matchers deleted by route id %d is %d", routeToDelete.Id, numberOfDeletedHeaderMatchers)

	if routeToDelete.StatefulSessionId != 0 {
		if err := dao.DeleteStatefulSessionConfig(routeToDelete.StatefulSessionId); err != nil {
			logger.Errorf("Failed to delete stateful session cookie during route cascade deletion: %v", err)
			return err
		}
	}

	err = dao.DeleteRouteByUUID(routeToDelete.Uuid)
	if err != nil {
		logger.Errorf("Can't delete route %v: %v", routeToDelete, err)
		return err
	}
	return nil
}

func (srv *Service) mergeAndStoreRoute(dao dao.Repository, existingRoute, updateRequest *domain.Route) error {
	updateRequest.Id = existingRoute.Id
	updateRequest.DeploymentVersion = existingRoute.DeploymentVersion
	updateRequest.InitialDeploymentVersion = existingRoute.InitialDeploymentVersion
	if err := srv.mergeRouteStatefulSession(dao, existingRoute, updateRequest); err != nil {
		return err
	}
	if err := dao.DeleteRouteByUUID(existingRoute.Uuid); err != nil {
		logger.Errorf("Failed to update existing route using DAO: %v", err)
		return err
	}
	if err := dao.SaveRoute(updateRequest); err != nil {
		logger.Errorf("Failed to update existing route using DAO: %v", err)
		return err
	}
	existingHeaderMatchers, err := dao.FindHeaderMatcherByRouteId(existingRoute.Id)
	if err != nil {
		logger.Errorf("Failed to load existing route header matchers using DAO: %v", err)
		return err
	}
	var headerMatchersToDelete []*domain.HeaderMatcher
	if updateRequest.HeaderMatchers == nil || len(updateRequest.HeaderMatchers) == 0 {
		if existingHeaderMatchers != nil {
			headerMatchersToDelete = existingHeaderMatchers
		}
	} else {
		var headerMatchersToSave []*domain.HeaderMatcher
		if existingHeaderMatchers == nil || len(existingHeaderMatchers) == 0 {
			headerMatchersToSave = updateRequest.HeaderMatchers
			for _, headerMatcherToSave := range headerMatchersToSave {
				headerMatcherToSave.Id = 0
				headerMatcherToSave.RouteId = updateRequest.Id
			}
		} else {
			headerMatchersToSave = updateRequest.HeaderMatchers
			if len(existingHeaderMatchers) > len(updateRequest.HeaderMatchers) {
				headerMatchersToDelete = existingHeaderMatchers[len(updateRequest.HeaderMatchers):]
			}
			for idx, newHeaderMatcher := range headerMatchersToSave {
				if idx >= len(existingHeaderMatchers) {
					newHeaderMatcher.Id = 0
					newHeaderMatcher.RouteId = updateRequest.Id
				} else {
					newHeaderMatcher.Id = existingHeaderMatchers[idx].Id
					newHeaderMatcher.RouteId = updateRequest.Id
				}
			}
		}
		for _, headerMatcher := range headerMatchersToSave {
			if err := dao.SaveHeaderMatcher(headerMatcher); err != nil {
				logger.Errorf("Failed to save route header matcher using DAO: %v", err)
				return err
			}
		}
	}
	if headerMatchersToDelete != nil {
		for _, headerMatcher := range headerMatchersToDelete {
			if err := dao.DeleteHeaderMatcher(headerMatcher); err != nil {
				logger.Errorf("Failed to delete route header matcher using DAO: %v", err)
				return err
			}
		}
	}
	if _, err := dao.DeleteHashPolicyByRouteId(updateRequest.Id); err != nil {
		return err
	}
	if updateRequest.HashPolicies != nil {
		for i := range updateRequest.HashPolicies {
			newHashPolicy := updateRequest.HashPolicies[i]
			newHashPolicy.RouteId = updateRequest.Id
			if err := dao.SaveHashPolicy(newHashPolicy); err != nil {
				return err
			}
		}
	}
	if err := dao.DeleteRetryPolicyByRouteId(updateRequest.Id); err != nil {
		return err
	}
	if updateRequest.RetryPolicy != nil {
		newRetryPolicy := updateRequest.RetryPolicy
		newRetryPolicy.RouteId = updateRequest.Id
		if err := dao.SaveRetryPolicy(newRetryPolicy); err != nil {
			return err
		}
	}
	return nil
}

func (srv *Service) FindRouteNodeGroup(dao dao.Repository, route *domain.Route) (*domain.NodeGroup, error) {
	routeConfig, err := srv.FindRouteConfigurationByVirtualHostId(dao, route.VirtualHostId)
	if err != nil {
		logger.Errorf("Failed to find RouteConfig by VirtualHost id using DAO:\n %v", err)
		return nil, err
	}
	return &domain.NodeGroup{Name: routeConfig.NodeGroupId}, nil
}

func (srv *Service) mergeRouteStatefulSession(dao dao.Repository, existingRoute, newRoute *domain.Route) error {
	if existingRoute.StatefulSessionId == 0 {
		if newRoute.StatefulSession == nil {
			return nil
		}
		// save new stateful session for the route
		return srv.saveRouteStatefulSession(dao, newRoute)
	} else {
		if newRoute.StatefulSession == nil {
			// delete stateful session for the route
			if err := dao.DeleteStatefulSessionConfig(existingRoute.StatefulSessionId); err != nil {
				logger.Errorf("Failed to delete existing route StatefulSession config using DAO:\n %v", err)
				return err
			}
			return nil
		}
		existingStatefulSession, err := dao.FindStatefulSessionConfigById(existingRoute.StatefulSessionId)
		if err != nil {
			logger.Errorf("Failed to find existing route stateful session using DAO:\n %v", err)
			return err
		}
		// update existing stateful session if needed
		newRoute.StatefulSession.Id = existingStatefulSession.Id
		if newRoute.StatefulSession.CookieName == "" {
			newRoute.StatefulSession.CookieName = existingStatefulSession.CookieName
		}
		if !newRoute.StatefulSession.Equals(existingStatefulSession) {
			if err := srv.saveRouteStatefulSession(dao, newRoute); err != nil {
				return err
			}
		}
		return nil
	}
}

func (srv *Service) saveRouteStatefulSession(dao dao.Repository, route *domain.Route) error {
	route.StatefulSession.DeploymentVersion = route.DeploymentVersion
	route.StatefulSession.InitialDeploymentVersion = route.InitialDeploymentVersion
	route.StatefulSession.ClusterName = clusterkey.DefaultClusterKeyGenerator.ExtractFamilyName(route.ClusterName)
	route.StatefulSession.Namespace = clusterkey.DefaultClusterKeyGenerator.ExtractNamespace(route.ClusterName).Namespace
	if err := srv.PutStatefulSession(dao, route.StatefulSession); err != nil {
		logger.Errorf("Failed to save new route StatefulSession using DAO:\n %v", err)
		return err
	}
	route.StatefulSessionId = route.StatefulSession.Id
	return nil
}

func (srv *Service) storeNewRoute(dao dao.Repository, newRoute *domain.Route) error {
	newRoute.Id = 0

	if newRoute.StatefulSession != nil {
		if err := srv.saveRouteStatefulSession(dao, newRoute); err != nil {
			return err
		}
	}
	if err := dao.SaveRoute(newRoute); err != nil {
		logger.Errorf("Failed to save new route using DAO: %v", err)
		return err
	}
	if newRoute.HeaderMatchers != nil && len(newRoute.HeaderMatchers) > 0 {
		for _, headerMatcher := range newRoute.HeaderMatchers {
			headerMatcher.Id = 0
			headerMatcher.RouteId = newRoute.Id
			if err := dao.SaveHeaderMatcher(headerMatcher); err != nil {
				logger.Errorf("Failed to save new route header matcher using DAO: %v", err)
				return err
			}
		}
	}
	retryPolicy := newRoute.RetryPolicy
	if retryPolicy != nil {
		retryPolicy.Id = 0
		retryPolicy.RouteId = newRoute.Id
		if err := dao.SaveRetryPolicy(retryPolicy); err != nil {
			logger.Errorf("Failed to save new route retry policy using DAO: %v", err)
			return err
		}
	}
	hashPolicies := newRoute.HashPolicies
	if hashPolicies != nil {
		for _, hashPolicy := range hashPolicies {
			hashPolicy.Id = 0
			hashPolicy.RouteId = newRoute.Id
			if err := dao.SaveHashPolicy(hashPolicy); err != nil {
				logger.Errorf("Failed to save new route hashPolicy using DAO: %v", err)
				return err
			}
		}
	}
	return nil
}

func (srv *Service) DeleteRouteCascade(dao dao.Repository, route *domain.Route) error {
	if _, err := dao.DeleteHeaderMatchersByRouteId(route.Id); err != nil {
		logger.Errorf("Failed to delete header matchers during route cascade deletion: %v", err)
		return err
	}
	if err := dao.DeleteRetryPolicyByRouteId(route.Id); err != nil {
		logger.Errorf("Failed to delete retry policy during route cascade deletion: %v", err)
		return err
	}
	if _, err := dao.DeleteHashPolicyByRouteId(route.Id); err != nil {
		logger.Errorf("Failed to delete hash policy during route cascade deletion: %v", err)
		return err
	}
	if err := dao.DeleteStatefulSessionConfig(route.StatefulSessionId); err != nil {
		logger.Errorf("Failed to delete stateful session cookie during route cascade deletion: %v", err)
		return err
	}
	return dao.DeleteRouteById(route.Id)
}
