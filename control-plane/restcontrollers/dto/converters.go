package dto

import (
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/domain"
)

var DefaultResponseConverter = converter{}

type converter struct{}

func (c converter) ConvertClustersToResponse(clusters []*domain.Cluster) []*ClusterResponse {
	clusterResponse := make([]*ClusterResponse, len(clusters))
	for idx, cluster := range clusters {
		clusterResponse[idx] = c.convertClusterToResponse(cluster)
	}
	return clusterResponse
}

func (c converter) ConvertRouteConfigurationsToResponse(routeConfigs []*domain.RouteConfiguration) []*RouteConfigurationResponse {
	routeConfigResponse := make([]*RouteConfigurationResponse, len(routeConfigs))
	for idx, routeConfig := range routeConfigs {
		routeConfigResponse[idx] = c.convertRouteConfiguration(routeConfig)
	}
	return routeConfigResponse
}

func (c converter) convertRouteConfiguration(routeConfig *domain.RouteConfiguration) *RouteConfigurationResponse {
	return &RouteConfigurationResponse{
		Id:           routeConfig.Id,
		Name:         routeConfig.Name,
		Version:      routeConfig.Version,
		NodeGroupId:  routeConfig.NodeGroupId,
		VirtualHosts: c.convertVirtualHosts(routeConfig.VirtualHosts),
	}
}

func (c converter) convertVirtualHosts(virtualHosts []*domain.VirtualHost) []*VirtualHost {
	virtualHostsDto := make([]*VirtualHost, len(virtualHosts))
	for idx, virtualHost := range virtualHosts {
		virtualHostsDto[idx] = c.ConvertVirtualHost(virtualHost)
	}
	return virtualHostsDto
}

func (c converter) ConvertVirtualHost(virtualHost *domain.VirtualHost) *VirtualHost {
	return &VirtualHost{
		Id:            virtualHost.Id,
		Name:          virtualHost.Name,
		Version:       virtualHost.Version,
		Domains:       c.convertDomains(virtualHost.Domains),
		Routes:        c.convertRoutes(virtualHost.Routes),
		RemoveHeaders: virtualHost.RequestHeadersToRemove,
		AddHeaders:    c.convertHeaders(virtualHost.RequestHeadersToAdd),
	}
}

func (c converter) convertDomains(domains []*domain.VirtualHostDomain) []string {
	domainsDto := make([]string, len(domains))
	for idx, domain := range domains {
		domainsDto[idx] = domain.Domain
	}
	return domainsDto
}

func (c converter) convertRoutes(routes []*domain.Route) []*Route {
	routesDto := make([]*Route, len(routes))
	for idx, route := range routes {
		routesDto[idx] = c.convertRoute(route)
	}
	return routesDto
}

func (c converter) convertRoute(route *domain.Route) *Route {
	return &Route{
		Id:                       route.Id,
		RouteKey:                 route.RouteKey,
		Uuid:                     route.Uuid,
		Version:                  route.Version,
		Autogenerated:            route.Autogenerated,
		Timeout:                  route.Timeout,
		IdleTimeout:              route.IdleTimeout,
		DeploymentVersion:        route.DeploymentVersionVal,
		InitialDeploymentVersion: route.InitialDeploymentVersion,
		HashPolicies:             c.convertHashPolicies(route.HashPolicies),
		DirectResponseAction:     c.convertDirectResponseAction(route.DirectResponseCode),
		RouteMatcher:             c.ConvertRouteMatcher(route),
		RouteAction:              c.convertRouteAction(route),
	}
}

func (c converter) convertDirectResponseAction(responseCode uint32) *DirectResponseAction {
	if responseCode == 0 {
		return nil
	}
	return &DirectResponseAction{Status: responseCode}
}

func (c converter) ConvertRouteMatcher(route *domain.Route) *RouteMatcher {
	prefix := domain.NewNullString(route.Prefix)
	path := domain.NewNullString(route.Path)
	regexp := domain.NewNullString(route.Regexp)
	if !prefix.Valid && !path.Valid && !regexp.Valid && len(route.HeaderMatchers) == 0 {
		return nil
	}
	return &RouteMatcher{
		Prefix:         prefix,
		Path:           path,
		Regexp:         regexp,
		HeaderMatchers: route.HeaderMatchers,
		RemoveHeaders:  route.RequestHeadersToRemove,
		AddHeaders:     c.convertHeaders(route.RequestHeadersToAdd),
	}
}

func (c converter) convertRouteAction(route *domain.Route) *RouteAction {
	if route.ClusterName == "" && route.PrefixRewrite == "" && route.RegexpRewrite == "" && route.PathRewrite == "" &&
		!route.HostAutoRewrite.Valid && route.HostRewrite == "" {
		return nil
	}
	return &RouteAction{
		ClusterName:     domain.NewNullString(route.ClusterName),
		PrefixRewrite:   domain.NewNullString(route.PrefixRewrite),
		RegexpRewrite:   domain.NewNullString(route.RegexpRewrite),
		PathRewrite:     domain.NewNullString(route.PathRewrite),
		HostAutoRewrite: route.HostAutoRewrite,
		HostRewrite:     domain.NewNullString(route.HostRewrite),
	}
}

func (c converter) convertClusterToResponse(cluster *domain.Cluster) *ClusterResponse {
	return &ClusterResponse{
		Id:            cluster.Id,
		Name:          cluster.Name,
		LbPolicy:      cluster.LbPolicy,
		Version:       cluster.Version,
		EnableH2:      cluster.EnableH2,
		NodeGroups:    cluster.NodeGroups,
		DiscoveryType: cluster.DiscoveryType,
		Endpoints:     c.convertEndpoints(cluster.Endpoints),
	}
}

func (c converter) convertEndpoints(endpoints []*domain.Endpoint) []*Endpoint {
	endpointsDto := make([]*Endpoint, len(endpoints))
	for idx, endpoint := range endpoints {
		endpointsDto[idx] = c.convertEndpoint(endpoint)
	}
	return endpointsDto
}

func (c converter) convertEndpoint(endpoint *domain.Endpoint) *Endpoint {
	return &Endpoint{
		Id:                       endpoint.Id,
		DeploymentVersion:        endpoint.DeploymentVersionVal,
		InitialDeploymentVersion: endpoint.InitialDeploymentVersion,
		Port:                     endpoint.Port,
		Address:                  endpoint.Address,
		HashPolicies:             c.convertHashPolicies(endpoint.HashPolicies),
	}
}

func (c converter) convertHashPolicies(hashPolicies []*domain.HashPolicy) []*HashPolicy {
	hashPoliciesDto := make([]*HashPolicy, len(hashPolicies))
	for idx, hashPolicy := range hashPolicies {
		hashPoliciesDto[idx] = c.convertHashPolicy(hashPolicy)
	}
	return hashPoliciesDto
}

func (c converter) convertHashPolicy(hashPolicy *domain.HashPolicy) *HashPolicy {
	hashPolicyDto := &HashPolicy{}
	hashPolicyDto.Id = hashPolicy.Id
	hashPolicyDto.Terminal = hashPolicy.Terminal
	if hashPolicy.HeaderName != "" {
		hashPolicyDto.Header = &Header{HeaderName: hashPolicy.HeaderName}
	}
	if hashPolicy.QueryParamSourceIP.Valid {
		hashPolicyDto.ConnectionProperties = &ConnectionProperties{SourceIp: hashPolicy.QueryParamSourceIP}
	}
	if hashPolicy.CookieName != "" {
		var ttlValue *int64
		if hashPolicy.CookieTTL.Valid {
			ttlValue = &hashPolicy.CookieTTL.Int64
		}

		hashPolicyDto.Cookie = &Cookie{
			Name: hashPolicy.CookieName,
			Path: domain.NewNullString(hashPolicy.CookiePath),
			Ttl:  ttlValue,
		}
	}
	if hashPolicy.QueryParamName != "" {
		hashPolicyDto.QueryParameter = &QueryParameter{Name: hashPolicy.QueryParamName}
	}
	return hashPolicyDto
}

func (c converter) convertHeaders(headers []domain.Header) []HeaderDefinition {
	headerDefinitions := make([]HeaderDefinition, len(headers), len(headers))
	for index, header := range headers {
		headerDefinitions[index] = HeaderDefinition{
			Name:  header.Name,
			Value: header.Value,
		}
	}
	return headerDefinitions
}

func ConvertFilterToDomain(filter *WasmFilter) *domain.WasmFilter {
	convertedParams := make(map[string]interface{}, len(filter.Params))

	for _, kv := range filter.Params {
		firstKey, firstValue := firstKey(kv)
		convertedParams[firstKey] = firstValue
	}

	return &domain.WasmFilter{
		Name:          filter.Name,
		URL:           filter.URL,
		SHA256:        filter.SHA256,
		TlsConfigName: filter.TlsConfigName,
		Timeout:       filter.Timeout,
		Params:        convertedParams,
	}
}

func ConvertWasmDomainToFilter(filter *domain.WasmFilter) WasmFilter {
	convertedParams := make([]map[string]any, 0, len(filter.Params))
	for k, v := range filter.Params {
		convertedParams = append(convertedParams, map[string]any{k: v})
	}
	return WasmFilter{
		Name:          filter.Name,
		URL:           filter.URL,
		SHA256:        filter.SHA256,
		TlsConfigName: filter.TlsConfigName,
		Timeout:       filter.Timeout,
		Params:        convertedParams,
	}
}

func ConvertLuaFilterToDomain(filter *LuaFilter) *domain.LuaFilter {
	return &domain.LuaFilter{
		Name:          filter.Name,
		LuaScript:     filter.LuaScript,
	}
}

func ConvertLuaDomainToFilter(filter *domain.LuaFilter) LuaFilter {
	return LuaFilter{
		Name:          filter.Name,
		LuaScript:     filter.LuaScript,
	}
}

func firstKey(m map[string]interface{}) (string, interface{}) {
	for k, v := range m {
		return k, v
	}
	return "", nil
}

func ConvertTLSToDomain(tlsConfig *TlsConfig) *domain.TlsConfig {
	return &domain.TlsConfig{
		NodeGroups: convertToNodeGroups(tlsConfig.TrustedForGateways),
		Name:       tlsConfig.Name,
		Enabled:    tlsConfig.Tls.Enabled,
		Insecure:   tlsConfig.Tls.Insecure,
		TrustedCA:  tlsConfig.Tls.TrustedCA,
		ClientCert: tlsConfig.Tls.ClientCert,
		PrivateKey: tlsConfig.Tls.PrivateKey,
		SNI:        tlsConfig.Tls.SNI,
	}
}

func ConvertRateLimitToDomain(rateLimit *RateLimit) *domain.RateLimit {
	return &domain.RateLimit{
		Name:                   rateLimit.Name,
		LimitRequestsPerSecond: uint32(rateLimit.LimitRequestPerSecond),
		Priority:               domain.PriorityFromString(rateLimit.Priority),
	}
}

func ConvertRateLimitToDTO(rateLimit *domain.RateLimit) RateLimit {
	return RateLimit{
		Name:                  rateLimit.Name,
		LimitRequestPerSecond: int(rateLimit.LimitRequestsPerSecond),
		Priority:              rateLimit.Priority.String(),
	}
}

func convertToNodeGroups(nodeGroups []string) []*domain.NodeGroup {
	convertedNodeGroups := make([]*domain.NodeGroup, len(nodeGroups))
	for i, ng := range nodeGroups {
		convertedNodeGroups[i] = &domain.NodeGroup{Name: ng}
	}
	return convertedNodeGroups
}
