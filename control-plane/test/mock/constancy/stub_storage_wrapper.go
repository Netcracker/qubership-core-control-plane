// Code generated by MockGen. DO NOT EDIT.
// Source: ../../constancy/storage_wrapper.go

// Package mock_constancy is a generated GoMock package.
package mock_constancy

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	bun "github.com/uptrace/bun"
)

// MockPGTxWrapper is a mock of PGTxWrapper interface.
type MockPGTxWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockPGTxWrapperMockRecorder
}

// MockPGTxWrapperMockRecorder is the mock recorder for MockPGTxWrapper.
type MockPGTxWrapperMockRecorder struct {
	mock *MockPGTxWrapper
}

// NewMockPGTxWrapper creates a new mock instance.
func NewMockPGTxWrapper(ctrl *gomock.Controller) *MockPGTxWrapper {
	mock := &MockPGTxWrapper{ctrl: ctrl}
	mock.recorder = &MockPGTxWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPGTxWrapper) EXPECT() *MockPGTxWrapperMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockPGTxWrapper) Commit(arg0 *bun.Tx) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockPGTxWrapperMockRecorder) Commit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockPGTxWrapper)(nil).Commit), arg0)
}

// Rollback mocks base method.
func (m *MockPGTxWrapper) Rollback(arg0 *bun.Tx) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockPGTxWrapperMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockPGTxWrapper)(nil).Rollback), arg0)
}

// MockPGConnWrapper is a mock of PGConnWrapper interface.
type MockPGConnWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockPGConnWrapperMockRecorder
}

// MockPGConnWrapperMockRecorder is the mock recorder for MockPGConnWrapper.
type MockPGConnWrapperMockRecorder struct {
	mock *MockPGConnWrapper
}

// NewMockPGConnWrapper creates a new mock instance.
func NewMockPGConnWrapper(ctrl *gomock.Controller) *MockPGConnWrapper {
	mock := &MockPGConnWrapper{ctrl: ctrl}
	mock.recorder = &MockPGConnWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPGConnWrapper) EXPECT() *MockPGConnWrapperMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockPGConnWrapper) Begin(conn *bun.Conn) (*bun.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", conn)
	ret0, _ := ret[0].(*bun.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockPGConnWrapperMockRecorder) Begin(conn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockPGConnWrapper)(nil).Begin), conn)
}

// Close mocks base method.
func (m *MockPGConnWrapper) Close(conn *bun.Conn) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", conn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockPGConnWrapperMockRecorder) Close(conn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPGConnWrapper)(nil).Close), conn)
}

// Model mocks base method.
func (m *MockPGConnWrapper) Model(conn *bun.SelectQuery, model interface{}) *bun.SelectQuery {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Model", conn, model)
	ret0, _ := ret[0].(*bun.SelectQuery)
	return ret0
}

// Model indicates an expected call of Model.
func (mr *MockPGConnWrapperMockRecorder) Model(conn, model interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Model", reflect.TypeOf((*MockPGConnWrapper)(nil).Model), conn, model)
}

// MockPGQueryWrapper is a mock of PGQueryWrapper interface.
type MockPGQueryWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockPGQueryWrapperMockRecorder
}

// MockPGQueryWrapperMockRecorder is the mock recorder for MockPGQueryWrapper.
type MockPGQueryWrapperMockRecorder struct {
	mock *MockPGQueryWrapper
}

// NewMockPGQueryWrapper creates a new mock instance.
func NewMockPGQueryWrapper(ctrl *gomock.Controller) *MockPGQueryWrapper {
	mock := &MockPGQueryWrapper{ctrl: ctrl}
	mock.recorder = &MockPGQueryWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPGQueryWrapper) EXPECT() *MockPGQueryWrapperMockRecorder {
	return m.recorder
}

// Scan mocks base method.
func (m *MockPGQueryWrapper) Scan(query *bun.SelectQuery) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Scan", query)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockPGQueryWrapperMockRecorder) Scan(query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockPGQueryWrapper)(nil).Scan), query)
}

// Select mocks base method.
func (m *MockPGQueryWrapper) Select(conn *bun.Conn) *bun.SelectQuery {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", conn)
	ret0, _ := ret[0].(*bun.SelectQuery)
	return ret0
}

// Select indicates an expected call of Select.
func (mr *MockPGQueryWrapperMockRecorder) Select(conn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockPGQueryWrapper)(nil).Select), conn)
}

// Where mocks base method.
func (m *MockPGQueryWrapper) Where(query *bun.SelectQuery, condition string, params interface{}) *bun.SelectQuery {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Where", query, condition, params)
	ret0, _ := ret[0].(*bun.SelectQuery)
	return ret0
}

// Where indicates an expected call of Where.
func (mr *MockPGQueryWrapperMockRecorder) Where(query, condition, params interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Where", reflect.TypeOf((*MockPGQueryWrapper)(nil).Where), query, condition, params)
}
