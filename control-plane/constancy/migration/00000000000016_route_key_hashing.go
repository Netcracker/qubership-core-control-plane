package migration

import (
	"context"
	"database/sql"
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/domain"
	"github.com/netcracker/qubership-core-control-plane/control-plane/v2/services/route/routekey"
	"github.com/pkg/errors"
	"github.com/uptrace/bun"
)

func init() {
	migrations.MustRegister(func(ctx context.Context, db *bun.DB) error {
		err := db.RunInTx(ctx, &sql.TxOptions{}, func(ctx context.Context, tx bun.Tx) error {
			log.Infof("#16 routeKey hashing")
			_, err := tx.Exec("ALTER TABLE routes ALTER COLUMN routeKey TYPE varchar(64) USING SUBSTR(routeKey, 1, 64)")
			if err != nil {
				return errors.Wrapf(err, "Can't alter routeKey column for routes table")
			}

			routesToUpdate := make([]*V16Route, 0)
			err = tx.NewSelect().Model(&routesToUpdate).Relation("HeaderMatchers").Scan(ctx)
			for _, r := range routesToUpdate {
				r.RouteKey = routekey.GenerateFunc(func() routekey.RouteMatch {
					rm := routekey.RouteMatch{
						Prefix:  r.Prefix,
						Regexp:  r.Regexp,
						Path:    r.Path,
						Version: r.DeploymentVersion,
					}
					headers := make([]routekey.HeaderMatch, len(r.HeaderMatchers))
					for i, hm := range r.HeaderMatchers {
						headers[i] = routekey.HeaderMatch{
							Name:           hm.Name,
							ExactMatch:     hm.ExactMatch,
							SafeRegexMatch: hm.SafeRegexMatch,
							PresentMatch:   hm.PresentMatch,
							PrefixMatch:    hm.PrefixMatch,
							SuffixMatch:    hm.SuffixMatch,
							InvertMatch:    hm.InvertMatch,
						}
						if hm.RangeMatch != nil {
							headers[i].RangeMatch = &routekey.RangeMatch{
								Start: hm.RangeMatch.Start.Int64,
								End:   hm.RangeMatch.End.Int64,
							}
						}
					}
					return rm
				})
			}

			if err != nil {
				log.Panicf("%v", err)
			}
			for _, route := range routesToUpdate {
				_, err = tx.NewUpdate().Model(route).Column("routekey").WherePK().Exec(ctx)
				if err != nil {
					log.Panic("can not update routekey: %s", err.Error())
				}
			}
			return nil
		})
		return err
	}, func(ctx context.Context, db *bun.DB) error {
		return nil
	})
}

type V16Route struct {
	bun.BaseModel            `bun:"routes"`
	Id                       int32              `bun:",pk" json:"id"`
	Uuid                     string             `bun:"uuid,notnull,type:varchar,unique" json:"uuid"`
	VirtualHostId            int32              `bun:"virtualhostid,notnull" json:"virtualHostId"`
	RouteKey                 string             `bun:"routekey,notnull" json:"routeKey"`
	DirectResponseCode       uint32             `bun:"directresponse_status" json:"directResponseCode"`
	Prefix                   string             `bun:"rm_prefix" json:"prefix"`
	Regexp                   string             `bun:"rm_regexp" json:"regexp"`
	Path                     string             `bun:"rm_path" json:"path"`
	ClusterName              string             `bun:"ra_clustername" json:"clusterName"`
	HostRewrite              string             `bun:"ra_hostrewrite" json:"hostRewrite"`
	HostAutoRewrite          *bool              `bun:"ra_hostautorewrite" json:"hostAutoRewrite"`
	PrefixRewrite            string             `bun:"ra_prefixrewrite" json:"prefixRewrite"`
	RegexpRewrite            string             `bun:"ra_regexprewrite" json:"regexpRewrite"`
	PathRewrite              string             `bun:"ra_pathrewrite" json:"pathRewrite"`
	Version                  int32              `bun:",notnull" json:"version"`
	DeploymentVersion        string             `bun:"deployment_version,notnull" json:"deploymentVersionString"`
	InitialDeploymentVersion string             `bun:"initialdeploymentversion,notnull" json:"initialDeploymentVersion"`
	Autogenerated            bool               `bun:"autogenerated,default:false" json:"autogenerated"`
	HeaderMatchers           []V16HeaderMatcher `bun:"rel:has-many,join:id=routeid" json:"headerMatchers"`
}

type V16HeaderMatcher struct {
	bun.BaseModel  `bun:"header_matchers"`
	Id             int32          `bun:",pk" json:"id"`
	Name           string         `bun:",notnull" json:"name"`
	Version        int32          `bun:",notnull" json:"version"`
	ExactMatch     string         `bun:"exactmatch" json:"exactMatch"`
	SafeRegexMatch string         `bun:"saferegexmatch" json:"safeRegexMatch"`
	RangeMatch     *V16RangeMatch `bun:"rangematch,type:jsonb" json:"rangeMatch"`
	PresentMatch   *bool          `bun:"presentmatch" json:"presentMatch"`
	PrefixMatch    string         `bun:"prefixmatch" json:"prefixMatch"`
	SuffixMatch    string         `bun:"suffixmatch" json:"suffixMatch"`
	InvertMatch    bool           `bun:"invertmatch,default:false" json:"invertMatch"`
	RouteId        int32          `bun:"routeid,notnull" json:"-"`
	Route          *V16Route      `bun:"rel:belongs-to,join:routeid=id" json:"-" yaml:"-"`
}

type V16RangeMatch struct {
	Start domain.NullInt `json:"start"`
	End   domain.NullInt `json:"end"`
}
