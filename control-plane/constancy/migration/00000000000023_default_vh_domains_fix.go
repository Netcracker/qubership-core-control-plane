package migration

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/go-errors/errors"
	"github.com/netcracker/qubership-core-control-plane/util/msaddr"
	"github.com/uptrace/bun"
	"strings"
)

func init() {
	migrations.MustRegister(func(ctx context.Context, db *bun.DB) error {
		err := db.RunInTx(ctx, &sql.TxOptions{}, func(ctx context.Context, tx bun.Tx) error {
			log.Info("#23 default virtual host domains fix")

			if err := fixDefaultVirtualHostDomains(&tx, ctx); err != nil {
				return errors.Wrap(err, 0)
			}

			if err := updateEnvoyRouteConfigVersion(ctx, &tx); err != nil {
				return errors.Wrap(err, 0)
			}

			log.Info("default virtual host domains fix (migration #23) applied successfully")
			return nil
		})
		return err
	}, func(ctx context.Context, db *bun.DB) error {
		return nil
	})
}

func correspondsToOldDefaultFormat(domain, virtualHostName, namespace string) bool {
	if namespace != "" {
		namespace = "." + namespace
	}
	return domain == virtualHostName ||
		domain == fmt.Sprintf("%s%s", virtualHostName, namespace) ||
		domain == fmt.Sprintf("%s%s.svc", virtualHostName, namespace) ||
		domain == fmt.Sprintf("%s%s.svc.cluster", virtualHostName, namespace) ||
		domain == fmt.Sprintf("%s%s.svc.cluster.local", virtualHostName, namespace)
}

// virtualHostHasDefaultDomains checks whether virtualHost has broken default domains value so it needs to be fixed.
// In case virtualHost has default domains, this function will return (true, namespace),
// where namespace is a namespace value calculated from existing virtualHost domains.
func virtualHostHasDefaultDomains(virtualHost *V23VirtualHost) (bool, string) {
	// default generated by old versions can contain only 4 or 5 values
	if len(virtualHost.Domains) != 4 && len(virtualHost.Domains) != 5 {
		return false, ""
	}
	// first calculate namespace of this virtual host and check there are no `*` and ports
	namespace := ""
	for _, vhDomain := range virtualHost.Domains {
		if strings.Contains(vhDomain.Domain, "*") {
			return false, ""
		}
		if strings.Contains(vhDomain.Domain, ":") {
			return false, ""
		}
		if strings.HasSuffix(vhDomain.Domain, ".svc") {
			if strings.Count(vhDomain.Domain, ".") >= 2 {
				namespace = vhDomain.Domain[len(virtualHost.Name)+1 : len(vhDomain.Domain)-4]
			}
		}
	}
	// now check that all values correspond to old default format
	for _, vhDomain := range virtualHost.Domains {
		if !correspondsToOldDefaultFormat(vhDomain.Domain, virtualHost.Name, namespace) {
			return false, ""
		}
	}
	return true, namespace
}

func fixDefaultVirtualHostDomains(db *bun.Tx, ctx context.Context) error {
	virtualHosts := make([]*V23VirtualHost, 0)

	err := db.NewSelect().Model(&virtualHosts).Relation("Domains").Scan(ctx)
	if err != nil {
		log.Errorf("Couldn't load virtual hosts: %v", err)
		return errors.Wrap(err, 0)
	}

	for _, virtualHost := range virtualHosts {
		if isBrokenDefault, namespace := virtualHostHasDefaultDomains(virtualHost); isBrokenDefault {
			log.Infof("Deleting default domains for virtual host %s: %+v", virtualHost.Name, virtualHost.Domains)
			if _, err := db.Exec("DELETE FROM virtual_host_domains WHERE VirtualHostId = ?", virtualHost.Id); err != nil {
				log.Errorf("Error deleting default virtual host domains: %v", err)
				return err
			}

			if err := fixDomainsForVirtualHost(db, ctx, virtualHost, namespace); err != nil {
				log.Errorf("Error fixing default virtual host domains: %v", err)
				return err
			}
		}
	}

	return nil
}

func fixDomainsForVirtualHost(db *bun.Tx, ctx context.Context, virtualHost *V23VirtualHost, namespace string) error {
	// by now (migration #23) virtualServices support only 8080 port
	// and likely no one has ever registered different clusters under the same virtualService
	// so let's make default domains generation as simple as possible
	if namespace == "" {
		namespace = msaddr.CurrentNamespaceAsString()
	}

	virtualHost.Domains = []V23VirtualHostDomain{
		{Domain: fmt.Sprintf("%s:8080", virtualHost.Name), Version: 1, VirtualHostId: virtualHost.Id},
		{Domain: fmt.Sprintf("%s.%s:8080", virtualHost.Name, namespace), Version: 1, VirtualHostId: virtualHost.Id},
		{Domain: fmt.Sprintf("%s.%s.svc:8080", virtualHost.Name, namespace), Version: 1, VirtualHostId: virtualHost.Id},
		{Domain: fmt.Sprintf("%s.%s.svc.cluster.local:8080", virtualHost.Name, namespace), Version: 1, VirtualHostId: virtualHost.Id},
	}

	for _, vhDomain := range virtualHost.Domains {
		if _, err := db.NewInsert().Model(&vhDomain).Exec(ctx); err != nil {
			log.Errorf("Failed to insert new virtual host domain: %v", err)
			return err
		}
	}
	return nil
}

type V23VirtualHost struct {
	bun.BaseModel          `bun:"table:virtual_hosts"`
	Id                     int32                  `bun:",pk"`
	Name                   string                 `bun:",notnull"`
	Version                int32                  `bun:",notnull"`
	RouteConfigurationId   int32                  `bun:"routeconfigid,notnull"`
	Domains                []V23VirtualHostDomain `bun:"rel:has-many,join:id=virtualhostid"`
	RequestHeadersToAdd    []V23Header            `bun:"request_header_to_add,type:jsonb"`
	RequestHeadersToRemove []string               `bun:"request_header_to_remove,type:jsonb"`
}

type V23Header struct {
	Name  string
	Value string
}

type V23VirtualHostDomain struct {
	bun.BaseModel `bun:"table:virtual_host_domains"`
	Domain        string `bun:",notnull,pk"`
	Version       int32  `bun:",notnull"`
	VirtualHostId int32  `bun:"virtualhostid,notnull,pk"`
}
