package dao

import (
	"github.com/netcracker/qubership-core-control-plane/domain"
)

func (d *InMemRepo) SaveRoute(route *domain.Route) error {
	txCtx := d.getTxCtx(true)
	defer txCtx.closeIfLocal()
	if err := d.idGenerator.Generate(route); err != nil {
		return err
	}
	// TODO implement generic optimistic lock or remove field Version
	route.Version = route.Version + 1
	return d.storage.Save(txCtx.tx, domain.RouteTable, route)
}

func (d *InMemRepo) SaveHeaderMatcher(headerMatcher *domain.HeaderMatcher) error {
	return d.SaveUnique(domain.HeaderMatcherTable, headerMatcher)
}

func (d *InMemRepo) DeleteHeaderMatcher(headerMatcher *domain.HeaderMatcher) error {
	return d.Delete(domain.HeaderMatcherTable, headerMatcher)
}

func (d *InMemRepo) FindAllRoutes() ([]*domain.Route, error) {
	return FindAll[domain.Route](d, domain.RouteTable)
}

func (d *InMemRepo) FindRoutesByAutoGeneratedAndDeploymentVersion(autoGenerated bool, dVersion string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "autoGenAndDVersion", autoGenerated, dVersion)
}

func (d *InMemRepo) FindRoutesByVirtualHostId(virtualHostId int32) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "virtualHostId", virtualHostId)
}

func (d *InMemRepo) FindHeaderMatcherByRouteId(routeId int32) ([]*domain.HeaderMatcher, error) {
	return FindByIndex[domain.HeaderMatcher](d, domain.HeaderMatcherTable, "routeId", routeId)
}

func (d *InMemRepo) DeleteHeaderMatcherById(id int32) error {
	return d.DeleteById(domain.HeaderMatcherTable, id)
}

func (d *InMemRepo) FindRoutesByVirtualHostIdAndRouteKey(vHostId int32, routeKey string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "vHostIdAndRouteKey", vHostId, routeKey)
}

func (d *InMemRepo) FindRoutesByDeploymentVersionAndRouteKey(deploymentVersion, routeKey string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "deploymentVersionAndRouteKey", routeKey, deploymentVersion)
}

func (d *InMemRepo) FindRoutesByDeploymentVersion(dVersion string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "dVersion", dVersion)
}

func (d *InMemRepo) FindRoutesByDeploymentVersionIn(dVersions ...string) ([]*domain.Route, error) {
	txCtx := d.getTxCtx(false)
	defer txCtx.closeIfLocal()
	routes := make([]*domain.Route, 0)
	for _, dVersion := range dVersions {
		if foundedRoutes, err := d.FindRoutesByDeploymentVersion(dVersion); err == nil {
			if foundedRoutes != nil {
				routes = append(routes, foundedRoutes...)
			}
		} else {
			return nil, err
		}
	}
	return routes, nil
}

func (d *InMemRepo) FindRoutesByDeploymentVersionStageIn(dVersionStage ...string) ([]*domain.Route, error) {
	txCtx := d.getTxCtx(false)
	defer txCtx.closeIfLocal()
	versions := make([]string, 0)
	for _, stage := range dVersionStage {
		if byStageDVersions, err := d.FindDeploymentVersionsByStage(stage); err == nil {
			if byStageDVersions != nil {
				for _, dVersion := range byStageDVersions {
					versions = append(versions, dVersion.Version)
				}
			}
		}
	}
	return d.FindRoutesByDeploymentVersionIn(versions...)
}

func (d *InMemRepo) FindRoutesByClusterName(clusterName string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "clusterName", clusterName)
}

func (d *InMemRepo) FindRoutesByClusterNamePrefix(clusterNamePrefix string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "clusterName_prefix", clusterNamePrefix)
}

func (d *InMemRepo) FindRoutesByClusterNameAndDeploymentVersion(clusterName, dVersion string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "clusterNameAndDVersion", clusterName, dVersion)
}

func (d *InMemRepo) FindRoutesByUUIDPrefix(prefixUuid string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "uuid_prefix", prefixUuid)
}

// TODO try to avoid full select
func (d *InMemRepo) FindRoutesByNamespaceHeaderIsNot(namespace string) ([]*domain.Route, error) {
	allRoutes, err := d.FindAllRoutes()
	if err != nil {
		return nil, err
	}
	filteredRoutes := make([]*domain.Route, 0)
	for _, r := range allRoutes {
		found := false
		headers, err := d.FindHeaderMatcherByRouteId(r.Id)
		if err != nil {
			return nil, err
		}
		for _, hm := range headers {
			if hm.Name == "namespace" && hm.ExactMatch != namespace {
				found = true
				break
			}
		}
		if found {
			filteredRoutes = append(filteredRoutes, r)
		}
	}
	return filteredRoutes, nil
}

// For cascade operations must be special service which make it in transaction
func (d *InMemRepo) DeleteRoutesByAutoGeneratedAndDeploymentVersion(autoGenerated bool, dVersion string) (int, error) {
	txCtx := d.getTxCtx(true)
	defer txCtx.closeIfLocal()
	deleted, err := txCtx.tx.DeleteAll(domain.RouteTable, "autoGenAndDVersion", autoGenerated, dVersion)
	if err != nil {
		return deleted, err
	}
	return deleted, err
}

func (d *InMemRepo) DeleteRouteById(routeId int32) error {
	return d.DeleteById(domain.RouteTable, routeId)
}

func (d *InMemRepo) DeleteRouteByUUID(uuid string) error {
	txCtx := d.getTxCtx(true)
	defer txCtx.closeIfLocal()
	_, err := txCtx.tx.DeleteAll(domain.RouteTable, "uuid", uuid)
	return err
}

func (d *InMemRepo) FindRouteByUuid(uuid string) (*domain.Route, error) {
	return FindFirstByIndex[domain.Route](d, domain.RouteTable, "uuid", uuid)
}

func (d *InMemRepo) FindRouteByStatefulSession(statefulSessionId int32) (*domain.Route, error) {
	return FindFirstByIndex[domain.Route](d, domain.RouteTable, "statefulSessionId", statefulSessionId)
}

func (d *InMemRepo) FindRoutesByRateLimit(rateLimitId string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "rateLimitId", rateLimitId)
}

func (d *InMemRepo) FindRouteById(routeId int32) (*domain.Route, error) {
	return FindById[domain.Route](d, domain.RouteTable, routeId)
}

func (d *InMemRepo) FindRoutesByDeploymentVersions(dVersions ...*domain.DeploymentVersion) ([]*domain.Route, error) {
	txCtx := d.getTxCtx(false)
	defer txCtx.closeIfLocal()
	routes := make([]*domain.Route, 0)
	for _, dVersion := range dVersions {
		if foundedRoutes, err := d.FindRoutesByDeploymentVersion(dVersion.Version); err == nil {
			if foundedRoutes != nil {
				routes = append(routes, foundedRoutes...)
			}
		} else {
			return nil, err
		}
	}
	return routes, nil
}

func (d *InMemRepo) FindRoutesByVirtualHostIdAndDeploymentVersion(virtualHostId int32, version string) ([]*domain.Route, error) {
	return FindByIndex[domain.Route](d, domain.RouteTable, "vHostIdAndDeploymentVersion", virtualHostId, version)
}

func (d *InMemRepo) DeleteHeaderMatchersByRouteId(routeId int32) (int, error) {
	txCtx := d.getTxCtx(true)
	defer txCtx.closeIfLocal()
	return txCtx.tx.DeleteAll(domain.HeaderMatcherTable, "routeId", routeId)
}
